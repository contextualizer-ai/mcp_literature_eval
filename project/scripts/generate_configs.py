#!/usr/bin/env python3
"""Generate agent-specific config files by merging templates with shared test cases.

This script creates evaluation config files by combining:
1. Agent-specific metadata from project/templates/*.yaml
2. Shared test case definitions from project/test_cases.yaml

Generated files are written to project/generated/ and should NOT be edited manually.
"""

import yaml
from pathlib import Path
from typing import Dict, Any
import sys


def load_test_cases(test_cases_path: Path) -> list[Dict[str, Any]]:
    """Load shared test case definitions."""
    with open(test_cases_path, 'r') as f:
        data = yaml.safe_load(f)
    return data['test_cases']


def load_template(template_path: Path) -> Dict[str, Any]:
    """Load agent-specific template."""
    with open(template_path, 'r') as f:
        return yaml.safe_load(f)


def merge_config(template: Dict[str, Any], test_cases: list[Dict[str, Any]]) -> Dict[str, Any]:
    """Merge template metadata with shared test cases."""
    config = template.copy()
    config['cases'] = test_cases
    return config


def write_config(config: Dict[str, Any], output_path: Path) -> None:
    """Write merged config to output file with header."""
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with open(output_path, 'w') as f:
        f.write('# AUTO-GENERATED FILE - DO NOT EDIT\n')
        f.write('# Generated by project/scripts/generate_configs.py\n')
        f.write('# \n')
        f.write('# To update this file:\n')
        f.write('# 1. Edit project/test_cases.yaml (for test case changes)\n')
        f.write('# 2. Edit project/templates/<template>.yaml (for agent/model config changes)\n')
        f.write('# 3. Run: python project/scripts/generate_configs.py\n')
        f.write('\n')
        yaml.safe_dump(config, f, default_flow_style=False, sort_keys=False, allow_unicode=True)


def generate_all_configs(
    templates_dir: Path,
    test_cases_path: Path,
    output_dir: Path
) -> Dict[str, Path]:
    """Generate all config files from templates and test cases.

    Returns:
        Dictionary mapping template names to generated config paths
    """
    # Load shared test cases
    print(f'Loading test cases from {test_cases_path}...')
    test_cases = load_test_cases(test_cases_path)
    print(f'  ✓ Loaded {len(test_cases)} test cases')

    # Template name mapping to output filenames
    template_to_output = {
        'claude_template.yaml': 'literature_mcp_eval_config_claude.yaml',
        'codex_template.yaml': 'literature_mcp_eval_config_codex.yaml',
        'gemini_template.yaml': 'literature_mcp_eval_config_gemini.yaml',
        'goose_claude_template.yaml': 'literature_mcp_eval_config_goose_claude.yaml',
        'goose_gpt4o_template.yaml': 'literature_mcp_eval_config_goose_gpt4o.yaml',
        'goose_gpt4o_mini_template.yaml': 'literature_mcp_eval_config_goose_gpt4o_mini.yaml',
        'goose_gpt5_template.yaml': 'literature_mcp_eval_config_goose_gpt5.yaml',
    }

    generated_files = {}

    print(f'\nGenerating config files...')
    for template_name, output_name in template_to_output.items():
        template_path = templates_dir / template_name
        output_path = output_dir / output_name

        # Load template
        template = load_template(template_path)

        # Merge with test cases
        config = merge_config(template, test_cases)

        # Write output
        write_config(config, output_path)

        generated_files[template_name] = output_path
        print(f'  ✓ {output_name}')

    return generated_files


def validate_consistency(generated_files: Dict[str, Path]) -> bool:
    """Validate that all generated files have identical test cases.

    Returns:
        True if all files have identical test cases, False otherwise
    """
    print(f'\nValidating test case consistency...')

    # Load test cases from each generated file
    all_test_cases = {}
    for template_name, config_path in generated_files.items():
        with open(config_path, 'r') as f:
            config = yaml.safe_load(f)
        all_test_cases[template_name] = config['cases']

    # Compare all against the first
    reference_name = list(all_test_cases.keys())[0]
    reference_cases = all_test_cases[reference_name]

    all_match = True
    for template_name, test_cases in all_test_cases.items():
        if template_name == reference_name:
            continue

        if test_cases != reference_cases:
            print(f'  ✗ {template_name} has different test cases than {reference_name}')
            all_match = False
        else:
            print(f'  ✓ {template_name} matches {reference_name}')

    return all_match


def main():
    """Main entry point."""
    # Paths
    project_dir = Path(__file__).parent.parent
    templates_dir = project_dir / 'templates'
    test_cases_path = project_dir / 'test_cases.yaml'
    output_dir = project_dir / 'generated'

    print('=' * 70)
    print('Metacoder Config Generator')
    print('=' * 70)

    # Validate inputs exist
    if not templates_dir.exists():
        print(f'Error: Templates directory not found: {templates_dir}')
        sys.exit(1)

    if not test_cases_path.exists():
        print(f'Error: Test cases file not found: {test_cases_path}')
        sys.exit(1)

    # Generate configs
    generated_files = generate_all_configs(templates_dir, test_cases_path, output_dir)

    # Validate consistency
    if validate_consistency(generated_files):
        print(f'\n✅ Success! All {len(generated_files)} config files generated with identical test cases')
        print(f'\nGenerated files are in: {output_dir}/')
        return 0
    else:
        print(f'\n❌ Error: Generated files have inconsistent test cases')
        return 1


if __name__ == '__main__':
    sys.exit(main())
